##### 什么是函数式编程

函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，避免了状态的变化和数据的可变。

##### 纯函数

有一个非常严格的定义：

- 如果给定相同的参数，则返回相同的结果(也称为**确定性**)。
- 它不会引起任何副作用。

函数读取外部文件，它不是纯函数，文件的内容随时可能都不一样。

任何依赖于随机数生成器的函数都不能是纯函数。

纯函数不会引起任何可观察到的副作用。可见副作用的例子包括修改全局对象或通过引用传递的参数。

纯函数是稳定的、一致的和可预测的。给定相同的参数，纯函数总是返回相同的结果。

咱们不需要考虑相同参数有不同结果的情况，因为它永远不会发生。

##### 纯函数的好处

纯函数代码肯定更容易测试，不需要 mock 任何东西,因此，我们可以使用不同的上下文对纯函数进行单元测试

##### 不可变性

尽管时间变或者不变，纯函数大佬都是不变的。

当数据是不可变的时，它的状态在创建后不能更改。

如何在遍历中处理可变性呢? 答案就是使用**递归**。使用递归，咱们保持变量不变。不会更改`list`和`accumulator`变量。它保持相同的值。

不可变数据是指那些创建后不能更改的数据。与许多其他语言一样，JavaScript 里有一些基本类型(String,Number 等)从本质上是不可变的，但是对象就是在任意的地方可变。

##### 引用透明性

基本上，如果一个函数对于相同的输入始终产生相同的结果，那么它可以看作透明的。

##### 函数是 JS 中的一级公民

函数作为 JS 中的一级公民，很风骚，函数也可以被看作成值并用作数据使用。

- 从常量和变量中引用它。
- 将其作为参数传递给其他函数。
- 作为其他函数的结果返回它。

其思想是将函数视为值，并将函数作为数据传递。通过这种方式，我们可以组合不同的函数来创建具有新行为的新函数。

##### 高阶函数

当我们讨论高阶函数时，通常包括以下几点：

- 将一个或多个函数作为参数
- 返回一个函数作为结果

我们经常用的`filter`、`map`和`reduce`都是高阶函数

##### Filter

对于给定的集合，我们希望根据属性进行筛选。`filter`函数期望一个`true`或`false`值来决定元素是否应该包含在结果集合中。

如果回调表达式为真，过滤器函数将在结果集合中包含元素，否则，它不会。

##### map

`map`函数的主要思路是转换集合。

`map`方法通过将函数应用于其所有元素并根据返回的值构建新集合来转换集合。

##### Reduce

`reduce`函数的思想是接收一个函数和一个集合，并返回通过组合这些项创建的值。

##### 函数式编程基础理论

函数式编程不是用函数来编程，也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数（计算理论，或者递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用。

函数是一等公民。所谓”第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。

不可改变量。在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了：在函数式编程中变量仅仅代表某个表达式。这里所说的’变量’是不能被修改的。所有的变量只能被赋一次初值。

map & reduce他们是最常用的函数式编程的方法。

1.函数是”第一等公民”

2.只用”表达式"，不用"语句"

3.没有”副作用"

4.不修改状态

5.引用透明（函数运行只靠参数）

##### 函数式编程常用核心概念

•纯函数

•函数的柯里化

•函数组合

•Point Free

•声明式与命令式代码

•核心概念

###### 1.纯函数

什么是纯函数呢？

对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态的函数，叫做纯函数。

###### 2.函数柯里化

传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。

###### 3.函数组合

为了解决函数嵌套过深，洋葱代码：h(g(f(x)))，我们需要用到“函数组合”，我们一起来用柯里化来改他，让多个函数像拼积木一样。

###### 4.Point Free

把一些对象自带的方法转化成纯函数,不要命名转瞬即逝的中间变量。

把一些对象自带的方法转化成纯函数，然后通过函数组合去调用，这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。

###### 5.声明式与命令式代码

在我们日常业务开发中，写的代码绝大多数都为命令式代码；

我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。

而声明式就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。

//命令式

let CEOs = [];

for (var i = 0; i < companies.length; i++) {

​    CEOs.push(companies[i].CEO)

}

//声明式

let CEOs = companies.map(c => c.CEO);

函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用它们的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于我们的心智来说是极大的负担。

###### 6.核心概念

###### 高阶函数

高阶函数，就是把函数当参数，把传入的函数做一个封装，然后返回这个封装函数,达到更高程度的抽象。

//命令式

var add = function(a,b){

  return a+b;

}

function math(func,array){

  return func(array[0],array[1]);

}

math(add,[1,2])//3

###### 递归与尾递归

指函数内部的最后一个动作是函数调用。 该调用的返回值， 直接返回给函数。 函数调用自身， 称为递归。 如果尾调用自身， 就称为尾递归。 递归需要保存大量的调用记录， 很容易发生栈溢出错误， 如果使用尾递归优化， 将递归变为循环， 那么只需要保存一个调用记录， 这样就不会发生栈溢出错误了。通俗点说，尾递归最后一步需要调用自身，并且之后不能有其他额外操作。

我们看一下递归和尾递归执行过程：

递归：

function sum(n) {

​    if (n === 1) return 1;

​    return n + sum(n - 1);

}

```
sum(5)
(5 + sum(4))
(5 + (4 + sum(3)))
(5 + (4 + (3 + sum(2))))
(5 + (4 + (3 + (2 + sum(1)))))
(5 + (4 + (3 + (2 + 1))))
(5 + (4 + (3 + 3)))
(5 + (4 + 6))
(5 + 10)
15 ``// 递归非常消耗内存，因为需要同时保存很多的调用帧，这样，就很容易发生“栈溢出”
```

尾递归

function sum(x, total) {

​    if (x === 1) {

​        return x + total;

​    }

​    return sum(x - 1, x + total);

}

```
sum(5, 0)
sum(4, 5)
sum(3, 9)
sum(2, 12)
sum(1, 14)
15
```

在ECMAScript 6，我们将迎来尾递归优化，通过尾递归优化，javascript代码在解释成机器码的时候，将会向while看起，也就是说，同时拥有数学表达能力和while的效能。

##### 范畴与容器

1.函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。
2.函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。

##### 容器与函子（Functor）

$(...) 返回的对象并不是一个原生的 DOM 对象，而是对于原生对象的一种封装，这在某种意义上就是一个“容器”（但它并不函数式）。

Functor（函子）遵守一些特定规则的容器类型。任何具有map方法的数据结构，都可以当作函子的实现。
Functor 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口 map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性。

一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。

因此，学习函数式编程，实际上就是学习函子的各种运算。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。

函数式编程一般约定，函子有一个of方法，用来生成新的容器。

###### 介绍一些常用的函子

###### Maybe 函子

函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。

###### 错误处理、Either函子

我们的容器能做的事情太少了，try/catch/throw 并不是“纯”的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。Promise 是可以调用 catch 来集中处理错误的。事实上 Either 并不只是用来做错误处理的，它表示了逻辑或。

条件运算if...else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。

###### AP函子

函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。

###### IO函子

IO 跟前面那几个 Functor 不同的地方在于，它的 __value 是一个函数。它把不纯的操作（比如 IO、网络请求、DOM）包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，IO 包含的是被包裹的操作的返回值。

IO其实也算是惰性求值。

IO负责了调用链积累了很多很多不纯的操作，带来的复杂性和不可维护性

Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。Promise 就是一种 Monad。Monad 让我们避开了嵌套地狱，可以轻松地进行深度嵌套的函数式编程，比如IO和其它异步任务。

#### 声明式的，不可变的，没有副作用的是函数式编程的三大护法。其中不可变武功最高深。

##### 实际应用场景 

###### 易调试、热部署、并发

1.函数式编程中的每个符号都是 const 的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。

2.函数式编程不需要考虑”死锁"（deadlock），因为它不修改变量，所以根本不存在"锁"线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署"并发编程"（concurrency）。

3.函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。

###### 单元测试

1.严格函数式编程的每一个符号都是对直接量或者表达式结果的引用，没有函数产生副作用。因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其他函数使用（如类成员或全局变量）。这意味着函数求值的结果只是其返回值，而惟一影响其返回值的就是函数的参数。

2.这是单元测试者的梦中仙境(wet dream)。对被测试程序中的每个函数，你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。而命令式编程就不能这样乐观了，在 Java 或 C++ 中只检查函数的返回值还不够——我们还必须验证这个函数可能修改了的外部状态。

#### 函数对于外部状态的依赖是造成系统复杂性大大提高的主要原因

#### 让函数尽可能地纯净

#### 函数式编程的核心理念：通过纯函数以及它们的组合、柯里化、Functor 等技术来降低系统复杂度

面向对象编程(OOP)通过封装变化使得代码更易理解。
函数式编程(FP)通过最小化变化使得代码更易理解。
-- Michacel Feathers（Twitter）

简单来说，函数式编程是一种强调以函数使用为主的软件开发风格。函数式编程的目的是使用函数来**抽象作用在数据之上的控制流和操作**，从而在系统中**消除副作用**并**减少对状态的改变。**

compose 简单解释一下，他会让函数从最后一个参数顺序执行到第一个参数，compose 的每个参数都是函数，

函数式编程属于声明式编程范式：这种范式会**描述一系列的操作**，但并不会**暴露它们是如何实现的**或是**数据流如何传过它们**。
