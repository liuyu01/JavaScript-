##### 单一职责

当一个组件只有一个改变的原因时，它有一个单一的职责。

编写React组件时要考虑的基本准则是单一职责原则。单一职责原则(缩写：`SRP`)要求组件有一个且只有一个变更的原因。

为什么只有一个理由可以改变很重要？因为这样组件的修改隔离并且受控。单一职责原则控制了组件的大小，使其集中在一件事情上。集中在一件事情上的组件便于编码、修改、重用和测试。

组合（composition）是一种通过将各组件联合在一起以创建更大组件的方式。组合是 React 的核心。

一种组件的变化对另一种组件的影响很小。这就是单一职责原则的作用：修改隔离，对系统的其他组件产生影响很轻微并且可预测。

##### 封装

一个封装组件提供 `props` 控制其行为而不是暴露其内部结构。

耦合是决定组件之间依赖程度的系统特性。根据组件的依赖程度，可区分两种耦合类型：

- 当应用程序组件对其他组件知之甚少或一无所知时，就会发生松耦合。
- 当应用程序组件知道彼此的许多详细信息时，就会发生紧耦合。

松耦合是我们设计应用结构和组件之间关系的目标。

###### 松耦合应用(封装组件)

**松耦合**会带来以下好处：

- 可以在不影响应用其它部分的情况下对某一块进行修改。、
- 任何组件都可以替换为另一种实现
- 在整个应用程序中实现组件复用，从而避免重复代码
- 独立组件更容易测试，增加了测试覆盖率

相反，紧耦合的系统会失去上面描述的好处。主要缺点是很难修改高度依赖于其他组件的组件。即使是一处修改，也可能导致一系列的依赖组件需要修改。

###### 紧耦合应用(组件无封装)

**封装** 或 **信息隐藏** 是如何设计组件的基本原则，也是松耦合的关键。

###### 信息隐藏

封装良好的组件隐藏其内部结构，并提供一组属性来控制其行为。

隐藏内部结构是必要的。其他组件没必要知道或也不依赖组件的内部结构或实现细节。

`React` 组件可能是函数组件或类组件、定义实例方法、设置 `ref`、拥有 `state` 或使用生命周期方法。这些实现细节被封装在组件内部，其他组件不应该知道这些细节。

隐藏内部结构的组件彼此之间的依赖性较小，而降低依赖度会带来松耦合的好处。

###### 通信

细节隐藏是隔离组件的关键。此时，你需要一种组件通信的方法：`props`。`porps` 是组件的输入

建议 `prop` 的类型为基本数据（例如，`string` 、 `number` 、`boolean`）：

必要时，使用复杂的数据结构，如对象或数组

`prop` 可以是一个事件处理函数和异步函数

`prop` 甚至可以是一个组件构造函数。组件可以处理其他组件的实例化

给子组件设置 `props` 的父组件不应该暴露其内部结构的任何细节。例如，使用 `props` 传输整个组件实例或 `refs` 都是一个不好的做法。

访问全局变量同样也会对封装产生负面影响。

##### 组合

一个组合式组件是由更小的特定组件组合而成的。

组合（composition）是一种通过将各组件联合在一起以创建更大组件的方式。组合是 React 的核心。

幸运的是，组合易于理解。把一组小的片段，联合起来，创建一个更大个儿。

React 组件的组合是自然而然的。这个库使用了一个声明范式，从而不会抑制组合式的表现力。

[单一责任原则](https://juejin.im/post/5d4acb28e51d45620771f082)描述了如何将需求拆分为组件，[封装](https://juejin.im/post/5d4c329e51882511ed7c203f)描述了如何组织这些组件，组合描述了如何将整个系统粘合在一起。

###### 组合的好处

单一责任：组合的一个重要方面在于能够从特定的小组件组成复杂组件的能力。这种分而治之的方式帮助了被组合而成的复杂组件也能符合 SRP 原则。

可重用：组合有可重用的有点，使用组合的组件可以重用公共逻辑

灵活：在 `react` 中，一个组合式的组件通过给子组件传递 `props` 的方式，来控制其子组件。这就带来了灵活性的好处。

高效：用户界面可组合的层次结构，因此，组件的组合是一种构建用户界面的有效的方式。

##### 复用

可重用的组件，一次编写多次使用。

符合单一职责原则是必须的：复用一个组件实际上就意味着复用其职责

只有一个职责的组件是最容易复用的。

`react-router` 使用了声明式的路由来构建一个单页应用。使用 `<Route>` 将 `URL` 和组件关联起来。当用户访问匹配的 `URL` 时，路由将渲染相应的组件。

`redux` 和 `react-redux` 引入了单向和可预测的应用状态管理。可以将异步的和非纯的代码（例如 `HTTP` 请求）从组件中提取出来，从而符合单一职责原则并创建出 纯（pure）组件 或 几乎纯（almost-pure）的组件。

##### 纯组件

纯组件总是为相同的属性值渲染相同的元素。几乎纯的组件总是为相同的属性值呈现相同的元素，但是会产生副作用。

而纯函数没有副作用且不依赖于全局状态。只要输入相同，输出一定相同。因此，纯函数的结果是可预测的，确定的，可以复用，并且易于测试。

`React` 组件也应该考虑设计为纯组件，当 `prop` 的值相同时， 纯组件(注意区分`React.PureComponent`)渲染的内容相同。

非纯组件是必要的，大多数应用程序中都需要全局状态，网络请求，本地存储等。你所能做的就是将 纯组件和非纯组件隔离，也就是说将你的组件进行**提纯**。

非纯代码显式的表明了它有副作用，或者是依赖全局状态。在隔离状态下，不纯代码对系统其它部分的不可预测的影响较小。
