##### 前端代码规范

###### 类型

1.基本类型赋值时，应该直接使用类型的值

2.复杂类型赋值其实是地址的引用

###### 状态的使用

3.所有的赋值都用const，避免使用var

4.如果一定要对参数重新赋值，就用let，而不是var

###### 对象

5.使用对象字面量方式创建对象

6.当创建一个带有动态属性名的对象时，将定义的所有属性放在对象的一个地方

7.方法简写

const atom = {

​    value : 1,

​    addValue(value){

​        return atom.value + value;

​    }

}

7.属性值缩写

const obj = {

​    lukeSkywalker

}

8.将属性的缩写放在对象声明的开头

9.只对那些无效的标示使用引号""

const good = {

​		foo : 3,

​        bar : 4,

​        'data-blah':5

};

10.不要直接调用Objet.prototype上的方法，如hasOwnProperty、propertyIsEnumerable、isPrototypeOf

11.对象浅拷贝时，更推荐使用扩展运算符...，而不是Object.assign。解构赋值获取对象指定的几个属性时，推荐用...

###### 数组

12.数组 使用字面量赋值

13.用push向数组中添加一个值而不是直接用下标。

14.用扩展运算符做数组浅拷贝

15.推荐用...运算符而不是Array.from来将一个类数组转换成数组。

16.用Array.from去将一个类数组对象转成一个数组。

17.用Array.from而不是...运算符去迭代。可以避免创建一个中间数组。

18.在数组方法的回调函数中使用return语句。如果函数体由一条返回一个表达式的语句组成，并且这个表达式没有副作用，这个时候可以忽略return。

19.如果一个数组有很多行，在数组的[后和]前换行。

###### 解构

20.用对象的解构赋值来获取和使用对象某个或多个属性值。

21.多个返回值用对象的解构，而不是数组解构。

function processInput(input){

​    return {left,right,top,bottom}

}

const {left,top} = processInput(input);

###### 字符串

22.string统一使用单引号''。

23.不应该用+连接换行字符串。不好用，且可读性差

24.用字符串模板而不是+来拼接字符串。模板字符串更具可读性、语法简洁、字符串插入参数。

25.永远不要在字符串中用eval()，漏洞太多。

26.不要使用不必要的转义字符。反斜线可读性差，只在必要时使用。

###### 函数

27.用命名函数表达式而不是函数声明。函数声明作用域会提升，降低了代码可读性和可维护性。如果你发现一个函数又大又复杂，这个函数妨碍这个文件其他部分的理解性，这可能就是时候把这个函数单独成一个模块了。

const short = function longUniqueMoreDescriptiveLexicalFoo(){};

28.把立即执行函数包裹在圆括号里。

29.不要在非函数块（if、while等）内声明函数。而是把这个函数分配给一个变量。浏览器允许你这样做，但浏览器解析方式不同，结果也许会有差异。

30.在ECMA-262中块block的定义是“一系列语句；但是函数声明不是一个语句。函数表达式是一个语句。

31.永远不要用arguments命名参数。它的优先级高于每个函数作用域自带的arguments对象，所以会导致函数自带的arguments值被覆盖。

//bad

function foo(name,options,arguments){}

32.优先使用rest语法...而不是arguments。

33.使用默认参数语法，而不是在函数里对参数重新赋值。

34.使用默认参数时，需要避免副作用。

35.把默认参数赋值放在最后

36.不要用Function创建函数。

37.函数签名部分要有空格。

const x = function () {};

const y = funciton a() {};

38.永远不要改参数。

39.不要对参数重新赋值。

40.活用...

41.多个参数的函数应该像这个指南里的其他行代码写法一样：每行只有一个参数，每行逗号结尾。

###### 箭头函数

42.如果要用匿名函数做回调，最好使用箭头函数

43.如果函数体由一个没有副作用的表达式的单个语句组成，去掉大括号和return。否则，保留大括号且使用return语句。

44.如果表达式有多行，首尾放在圆括号里更可读。

45.为了清晰和一致，始终在参数周围加上括号。

46.避免箭头函数语法 => 和比较操作符 <= >=混淆。

47.使用隐式返回时强制约束函数体在箭头后面。

###### 类和构造函数

48.始终用class，避免直接操作prototype

49.使用extends实现继承

50.方法可以返回this来实现方法链

51.允许写一个自定义的toString()方法，但是要保证它是可以正常工作且没有副作用

52.如果没有特殊说明，类有默认的构造方法。不用特意写一个空的构造函数或只是代表父类的构造函数。

53.避免重复类的成员。重复类成员会默默的执行最后一个，有重复肯定就是一个错误。

###### 模块

54.在非标准模块系统上使用（import/export）。或者随时换成其他的首选模块系统。

55.不要用import * 这种通配符

56.不要直接从import中直接export

57.一个入口只import一次

58.不要导出可变的绑定

59.在只有一个导出的模块里，用export default更好。鼓励使用更多文件，每个文件只做一件事情并导出，这样可读性和可维护性更好。

60.import放在其他所有语句之前。

61.多行import应该缩进，就像多行数组和对象字面量

62.在import语句里不允许Webpack loader语法

###### 迭代器和生成器

63.不要用迭代器。用JavaScript高阶函数代替for-in、for-of。

不可变原则，处理纯函数的返回值比处理副作用更容易。

数组的迭代方法：map()、every()、filter()、find()、findIndex()、reduce()、some()

对象的处理方法：Object.keys()、Object.values()、Object.entries()去产生一个数组，这样就能去遍历对象了。

64.现在不要用generator

65.如果一定要用，请确保它们的函数签名之间的空格是正确的。

const foo = funciton* () {}

###### 属性

66.访问属性时使用点符号.

67.获取的属性是变量时用方括号[]

68.做幂运算时用幂操作符**

###### 变量

69.始终用const或let声明变量。

70.每个变量单独用一个const或let.

71.const放一起，let放一起

72.变量声明放在合理的位置

73.不要使用连续变量分配。连接变量分配创建隐式全局变量。

74.不要使用一元递增递减运算符（++，--）

根据 eslint 文档，一元递增和递减语句受到自动分号插入的影响，并且可能会导致应用程序中的值递增或递减的静默错误。 使用num += 1 而不是 num++ 或代替语句来改变你的值也更具表现力。禁止一元递增和递减语句也会阻止您无意中预先递增/预递减值，从而减少程序出现意外行为。

75.避免在=前/后换行。如果你的语句超出max-len,那就用()把这个值包起来再换行。

76.不允许有未使用的变量。

###### 提升

77.var声明被提升。const和let声明被赋予一个所谓的新概念 TDZ

78.匿名函数表达式和var情况相同

79.已命名的函数表达式提升它的变量名，而不是函数名或函数体

80.函数声明则提升函数名和函数体

###### 比较和相等

81.使用===和！==而不是==和！=

82.布尔值比较可以省略，但是字符串和数字要显示比较

83.switch case中，在case和default分句里用大括号创建一个块（如：let,const,function,and class）

84.三元表达式不应该嵌套，通常是单行表达式

85.避免不需要的三元表达式

86.混合操作符时，要放在()里，只有当它们是标准的算术运算符（+，-，*，/）,并且它们的优先级显而易见时，可以不用。

###### 块

87.用大括号{}包裹多行代码块。

88.else和if的大括号保持在一行。

89.如果if语句都要用return返回，那后面的else就不用写了。如果if块中包含return，它后面的else if 块中也包含了return，这个时候就可以把else if 拆开。

###### 控制

90.当你的控制语句if、while等太长或者超过最大长度限制的时候，把每个判断条件放在单独一行里，逻辑运算符放在行首。

91.不要用选择操作符代替控制语句。

###### 注释

92.多行注释用/** ... */

93.单行注释用//，将单行注释放在被注释区域上方。如果注释不是在第一行，就在注释钱面加一个空格。

94.所有注释开头加一个空格，方便阅读。//  is current tab

95.在注释前加上FIXME 或TODO前缀，这有助于其他开发人员快速理解你指出的问题，或者您建议的问题的解决方案。

###### 空格

96.Tab使用2个空格（或者4个，必须是统一的）

97.在大括号{}前空一格。

98.在控制语句if while等的圆括号前空一格。在函数调用和定义时，函数名和圆括号之间不空格。

99.用空格来隔开运算符。

100.文件结尾空一行

101.当出现长的方法链（一般超过两个的时候）时换行。用点开头强调该行是一个方法调用，而不是一个新的语句。

102.在一个代码块之后，下一条语句之前空一行。

103.不要故意留一些没必要的空白行。

104.圆括号里不要加空格。

105.方括号里不要加空格。

106.花括号{}里加空格。

107.避免一行代码超过100个字符（包含空格、纯字符串就不要换行了）

108.逗号,前避免空格 逗号,后需要空格

109.在对象属性中，键值之间要有空格。

110.行末不要空格。

111.避免出现多个空行。在文件末尾只允许空一行。

###### 逗号

112.不要前置逗号

###### 分号

113.明确地使用分号

###### 命名约定

114.避免用一个字母命名，让你的命名更加语义化。

115.用camelCase命名你的对象、函数、实例。

116.不要前置或后置下划线。

117.不要保存this的引用，使用箭头函数或硬绑定。

118.文件名应与默认导出（export default）的名称完全匹配

119.默认导出（`export default`）一个函数时，函数名、文件名统一。

120.当你 export 一个构造函数/类/单例/函数库对象时用 PascalCase。

**const** AirbnbStyleGuide = {
es6: {
}
};
**export** **default** AirbnbStyleGuide;

121. 简称和首字母缩写应该全部大写或全部小写。
122. 全大写字母定义用来导出的常量

###### 访问器

123.不需要使用属性的访问器函数。

124.不要使用 JavaScript 的 getters/setters，因为他们会产生副作用，并且难以测试、维护和理解。如果必要，你可以用 getVal()和 setVal() 去构建。

125.如果属性/方法是一个 `boolean`， 请用 `isVal()` 或 `hasVal()`。

126.可以用 get() 和 set() 函数，但是要保持一致。

###### Events

127. 给事件或其他传递数据时，不直接使用原始值，而是通过对象包装。这样在未来需要增加或减少参数，不必找到每个使用中的处理器。
