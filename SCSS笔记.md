##### SCSS笔记

Sass(英文全称：Syntactically Awesome Stylesheets)是一个最初由Hampton Catlin 设计并由Natalie Weizenb aum开发的层叠样式表语言。

Sass是一个CSS预处理器。

Sass是CSS扩展语言，可以帮助我们减少CSS重复的代码，节省开发时间。

Sass完全兼容所有版本的CSS。

Sass扩展了CSS3，增加了规则、变量、混入、选择器、继承、内置函数等等特性。

Sass生成良好格式化的CSS代码，易于组织和维护。

Sass文件后缀为.scss。

###### Sass是如何工作的？

浏览器并不支持Sass代码。因此，你需要使用一个Sass预处理器将Sass代码转换为CSS代码。

###### 句法

Sass支持两种不同的语法。每个人都可以加载另一个，所以由您和您的团队选择哪个。

###### SCSS

该SCSS语法使用的文件扩展名`.scss`。有几个小的例外，它的超集CSS，这意味着基本上**所有有效的CSS是有效SCSS 也**。由于它与CSS相似，因此它是最容易习惯且最受欢迎的语法。

SCSS看起来像这样：

```
@mixin button-base() {
  @include typography(button);
  @include ripple-surface;
  @include ripple-radius-bounded;

  display: inline-flex;
  position: relative;
  height: $button-height;
  border: none;
  vertical-align: middle;

  &:hover { cursor: pointer; }

  &:disabled {
    color: $mdc-button-disabled-ink-color;
    cursor: default;
    pointer-events: none;
  }
}
```

###### 缩进语法

缩进语法是Sass的原始语法，因此它使用文件扩展名`.sass`。由于此扩展，它有时仅称为“ Sass”。缩进语法支持与SCSS相同的所有功能，但是它使用缩进代替花括号和分号来描述文档的格式。

通常，任何时候用CSS或SCSS编写花括号时，都可以缩进语法缩进一个级别。只要一行结束，就算作分号。在整个参考文献中，缩进语法中还存在一些其他差异。

缩进的语法如下所示：

```
@mixin button-base()
  @include typography(button)
  @include ripple-surface
  @include ripple-radius-bounded

  display: inline-flex
  position: relative
  height: $button-height
  border: none
  vertical-align: middle

  &:hover
    cursor: pointer

  &:disabled
    color: $mdc-button-disabled-ink-color
    cursor: default
    pointer-events: none
```



###### 0.嵌套规则（Nested Rules）

Sass允许将一套CSS样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：

```
#main p {
	color: #00ff00;
	width: 97%;
	.redbox{
		background-color:#ff0000;
		color:#000000;
	}
}
```

编译为：

```
#main p{
	color: #00ff00;
	width:97%;
}
#main p .rebbox{
    background-color:#ff0000;
	color:#000000;
}
```

嵌套功能避免了重复输入父选择器，而且令复杂的CSS结构更易于管理

###### 1.父选择器&

在嵌套CSS规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定hover样式时，或者当body元素有某个classname时，可以用&代表嵌套规则外层的父选择器。

```
a{
	font-weight:bold;
	text-decoration:none;
	&:hover{
		text-decoration:underline;
	}
	body.firefox &{
		font-weight:normal;
	}
}
```

编译为：

```
a{
	font-weight:bold;
	text-decoration:none;
}
a:hover{
	text-decoration:underline;
}
body.firefox a{
	font-weight:normal;
}
```

编译后的CSS文件中&将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递。

&必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如：

```
#main{
	color: black;
	&-sidebar{ border: 1px solid; }
}
```

编译为

```
#main{
	color:black;
}
#main-sidebar{
	border:1px solid;
}
```

当父选择器含有不合适的后缀时，Sass将会报错。

属性嵌套（Nested Properties）

有些CSS属性遵循相同的命名空间（namespace）,比如font-family，font-size，font-weight都以font作为属性的命名空间。为了便于管理这样的属性，同时也为了避免重复输入，Sass允许将属性嵌套在命名空间中，例如：

```
.funky{
	font:{
		family:fantasy;
		size:30em;
		weight:bold;
	}
}
```

编译为

```
.funky{
	font-family: fantasy;
	font-size: 30em;
	font-weight: bold;
}
```

命名空间也可以包含自己的属性值，例如：

```
.funky{
	font: 20px/24px{
		family:fantasy;
		weight:bold;
	}
}
```

编译为

```
.funky{
	font:20px/24px;
	font-family:fantasy;
	font-weight:bold;
}
```

###### 2.占位符选择器%foo

Sass额外提供了一种特殊类型的选择器：占位符选择器（placeholder selector）。与常用的id与class选择器写法相似，只是#或.替换成了%.必须通过@extend指令调用。

当占位符选择器单独使用时（未通过@extend调用），不会编译到CSS文件中。

###### 3.注释 /* */与 //

Sass支持标准的CSS多行注释 /* */，以及单行注释//，前者(多行)会被完整输出到编译后的CSS文件中，而后者(单行)则不会。

将！作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到CSS文件中，通常用于添加版权信息。

插值语句也可写进多行注释中输出变量值

```
$version: '1.2.3';
/* This CSS is generated by My Snazzy Framework version #{$version}. */
```

编译为

```
/* This CSS is generated by My Snazzy Framework version 1.2.3. */
```

###### 4.变量$

变量以美元符号开头，赋值方法与CSS属性的写法一样：

```
$width: 5em;
```

直接使用即调用变量：

```
#main{
	width: $width;
}
```

变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可以在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加!global声明

```
#main{
	$width: 5em !global;
	width: $width;
}
#sidebar{
	width: $width;
}
```

编译为

```
#main{
	width: 5em;
}
#sidebar{
	width: 5em;
}
```

###### 5.数据类型

支持6种主要的数据类型：

- 数字， 1, 2, 13，10px
- 字符串，有引号字符与无引号字符串， "foo", "bar", baz
- 颜色， blue, #04a3f9, rgba(255,0,0,0.5)
- 布尔型， true, false
- 空值， null
- 数组（list），用空格或逗号作为分隔符， 1.5em 1em 0 2em, Helvetica,  Arial，sans-serif
- maps，相当于JavaScript的object, (key1:value1, key2: value2) 

###### 6.函数

SassScript定义了多种函数，有些甚至可以通过普通的CSS语句调用：

```
p{
	color: hsl(0, 100%, 50%)
}
```

编译为

```
p{
	color: #ff0000;
}
```

关键词数（Keyword Arguments）

Sass函数允许使用关键词参数

```
p {
	color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
}
```

关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。

###### 7.插值语句#{}（Interpolation: #{}）

通过#{}插值语句可以在选择器或属性名中使用变量

```
$name: foo;
$attr: border;
p.#{$name}{
	#{$attr}-color: blue;
}
```

编译为

```
p.foo{
	border-color: blue;
}
```

#{}插值语句也可以在属性值中插入SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用#{}可以避免Sass运行运算表达式，直接编译CSS.

###### 8.变量定义 !default

可以在变量的结尾添加 `!default` 给一个未通过 `!default` 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。

```
$content: "First content";
$content: "Second content?" !default;
$new_content: "First time reference" !default;

#main {
  content: $content;
  new-content: $new_content;
}
```

编译为

```
#main {
  content: "First content";
  new-content: "First time reference"; 
}
```

###### 9.@import 

Sass 拓展了 `@import` 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。

通常，`@import` 寻找 Sass 文件并将其导入，但在以下情况下，`@import` 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。

- 文件拓展名是 `.css`；
- 文件名以 `http://` 开头；
- 文件名是 `url()`；
- `@import` 包含 media queries。

如果不在上述情况内，文件的拓展名是 `.scss` 或 `.sass`，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 `.scss` 或 `.sass` 的文件并将其导入。

CSS原生的@import会通过额外的HTTP请求获取引入的样式片段，而SASS的@import则会直接将这些引入的片段合并至当前CSS文件，并且不会产生新的HTTP请求。

SASS中引入片断时，可以缺省使用文件扩展名。

包含文件时不需要指定文件后缀，Sass 会自动添加后缀 .scss。

###### 10.@media

Sass 中 `@media` 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 `@media` 嵌套在 CSS 规则内，编译时，`@media` 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 `@media` 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。

###### 11.继承 @extend

使用 `@extend` 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。

`@extend` 的作用是将重复使用的样式 (`.error`) 延伸 (extend) 给需要包含这个样式的特殊样式（`.seriousError`）

可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码。

###### 12.操作符

SASS提供了标准的算术运算符，例如+、-、*、/、%。

###### 13.混合（Mixin）

混合（Mixin）用来分组哪些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活。使用@mixin name 指令来进行混合操作。是可以重用的代码块。

使用@mixin命令，定义一个代码块

```
@mixin border-radius($radius) {
          border-radius: $radius;
      -ms-border-radius: $radius;
     -moz-border-radius: $radius;
  -webkit-border-radius: $radius;
}
//使用@include 命令，调用这个mixin
.box {
  @include border-radius(10px);
}
```

编译为

```
.box {
  border-radius: 10px;
  -ms-border-radius: 10px;
  -moz-border-radius: 10px;
  -webkit-border-radius: 10px; 
 }
```

mixin的强大之处，在于可以指定参数和缺省值。

###### 14.

- 使用 [加载模块](https://sass-lang.com/documentation/at-rules/use)`@use`。
- 使用 [导入](https://sass-lang.com/documentation/at-rules/import)`@import`。
- 使用的 [Mixin定义](https://sass-lang.com/documentation/at-rules/mixin)`@mixin`。
- 使用的 [函数定义](https://sass-lang.com/documentation/at-rules/function)`@function`。
- [样式规则](https://sass-lang.com/documentation/style-rules)，如 `h1 { /* ... */ }`。
- [CSS规则](https://sass-lang.com/documentation/at-rules/css)，如`@media`和 `@font-face`。
- [Mixin](https://sass-lang.com/documentation/at-rules/mixin)使用 `@include`。
- 该[`@at-root`规则](https://sass-lang.com/documentation/at-rules/at-root)。

###### 15.高级用法：

@if 可以用来判断

@else

for循环 @for

while循环 @while

each命令，作用与for类似：@each

允许用户编写自己的函数

```
@function double($n){
	@return $n * 2;
}
#sidebar{
	width: double(5px);
}
```

###### 16.Sass Partials

如果你不希望将一个Sass的代码文件编译到一个CSS文件，你可以在文件名的开头添加一个下划线。这将告诉Sass不要将其编译到CSS文件。但是，在导入语句中我们不需要添加下划线。

**注意：**请不要将带下划线与不带下划线的同名文件放置在同一个目录下，比如，_colors.scss 和 colors.scss 不能同时存在于同一个目录下，否则带下划线的文件将会被忽略。

###### 17.CSS3中有四种不同的组合器

1.后代选择器（空间）

2.子选择器（>）

3.邻接兄弟选择器（+）

4.一般兄弟选择器（~）

注意：<在CSS选择中无效。

E > F 表示选择E元素的所有子F元素，与E F的区别在于，E F选择所有后代元素，>只选择一代。 没有<的用法。

E+F表示HTML中紧随E的F元素

为所有相同的父元素中位于 p 元素之后的所有 ul 元素设置背景：

```
`p~ul`{
　　background``:``#ff0000``;
}
```

定义和用法

p~ul选择器 p之后出现的所有ul。

两种元素必须拥有相同的父元素，但是 ul不必直接紧随 p。
